import parser from "@babel/parser";
import traverse from "@babel/traverse";
import * as t from "@babel/types";
import { transformFromAst, transformFromAstAsync } from "@babel/core";
import hasCycle from "./graph.mjs";
const root = "/Users/panchalkiritbhai/dev/proj/projects/bun-dler/project";
const mainFile = "./main.js";

async function createAsset(assetPath) {
  // TODO: Add error handling for reading files

  const content = await Bun.file(assetPath).text();
  const ast = parser.parse(content, {
    sourceType: "module",
  });

  const dependencies = new Set();

  traverse(ast, {
    ImportDeclaration: {
      enter(path) {
        dependencies.add(path.node.source.value);
      },
    },

    CallExpression: {
      enter(path) {
        if (t.isIdentifier(path.node.callee, { name: "require" })) {
          // TODO: Validation for arugments
          dependencies.add(path.node.arguments[0].value);
        }
      },
    },
  });

  // generate code from ast
  //Transpilation to maintain compatibility.
  const { code } = await transformFromAstAsync(ast, content, {
    presets: ["@babel/preset-env"],
  });

  return {
    assetPath,
    dependencies,
    content: code,
  };
}

function resolveDependecyPath(depPath, rootPath) {
  return Bun.resolveSync(depPath, rootPath);
}

async function generateDependencyGraph(entryPath, rootPath) {
  const entryAsset = await createAsset(entryPath);
  const queue = [entryAsset];

  const assets = new Map(); // mapping of asset id to asset
  const graph = new Map(); // directed graph of dependencies
  entryPath = resolveDependecyPath(entryPath, rootPath);
  assets.set(enterPath, entryAsset);
  while (queue.length != 0) {
    const asset = queue.shift();
    asset.depMap = new Map(); // mapping of dependency to module id

    const dependencies = [];
    for (const dep of asset.dependencies) {
      // TODO: Add error handling in resolving paths
      const filePath = resolveDependecyPath(dep, rootPath);
      if (!assets.has(filePath)) {
        // TODO: Add error handling for creating dependencies
        dependencies.push(filePath);
        const childAsset = await createAsset(filePath);
        asset.depMap.set(dep, filePath);
        assets.set(dep, childAsset);
        queue.push(childAsset);
      }
    }
    graph.set(asset.assetPath, dependencies);
  }
  return [assets, graph];
}

function createBundle(assets, entryPath) {
  let modules = "{";

  assets.forEach((asset) => {
    const scopeIsolation = `function(require,module,exports){${asset.content}}`;
    modules += `"${asset.assetPath}": [${scopeIsolation}, ${JSON.stringify(
      Object.fromEntries(asset.depMap)
    )}],`;
  });

  modules += "}";

  let bundle = `(function (modules, startPath) {
    function require(path) {
  
      const [fn, depMap] = modules[path];
      const module = { exports: {}};
      function localRequire(slug) {
        if (slug == startPath) {
          return {};
        }
        return require(depMap[slug]);
      }
      fn(localRequire, module, module.exports);
      return module.exports;
    }
    require(startPath);
  })(${modules}, "${entryPath}");`;

  return bundle;
}

const enterPath = Bun.resolveSync(mainFile, root);
const [assets, graph] = await generateDependencyGraph(enterPath, root);

// TODO: Check for circular dependencies

console.log(hasCycle(graph, enterPath));

const bundle =
  "// This code is generated by a toy bun-dler\n" +
  createBundle(assets, enterPath);

const bundlePath = "./bundle.js";
await Bun.write(bundlePath, bundle);
