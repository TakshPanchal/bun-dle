import path from "path";
import { hasCycle, generateDependencyGraph } from "./graph.mjs";
import { parseArgs } from "util";
import { showError } from "./logging";
import chalk from "chalk";
import { log } from "console";

// parse arguments
const { values } = parseArgs({
  options: {
    entryPoint: {
      type: "string",
      short: "e",
    },
    root: {
      type: "string",
      short: "r",
    },
  },
  strict: true,
});

if (!Object.hasOwn(values, "entryPoint")) {
  showError("Entry point is required");
}

if (!Object.hasOwn(values, "root")) {
  showError("Root path is required");
}

const root = path.resolve(values.root);
const enterPath = path.resolve(root, values.entryPoint);

function createBundle(assets, entryAssetId) {
  let modules = "{";

  assets.forEach((asset) => {
    const scopeIsolation = `function(require,module,exports){${asset.content}}`;
    modules += `"${asset.id}": [${scopeIsolation}, ${JSON.stringify(
      Object.fromEntries(asset.depMap)
    )}],`;
  });

  modules += "}";

  let bundle = `(function (modules, startPath) {
    function require(path) {
  
      const [fn, depMap] = modules[path];
      const module = { exports: {}};
      function localRequire(slug) {
        if (slug == startPath) {
          return {};
        }
        return require(depMap[slug]);
      }
      fn(localRequire, module, module.exports);
      return module.exports;
    }
    require(startPath);
  })(${modules}, "${entryAssetId}");`;

  bundle = "// This code is generated by a toy bun-dler\n" + bundle;
  return bundle;
}

const [assets, graph, entryAsset] = await generateDependencyGraph(
  enterPath,
  root
);

const [isGraphCyclic, cyclicPath] = hasCycle(graph, enterPath, entryAsset.id);
if (isGraphCyclic) {
  showError("Warning: Circular dependency detected in file: " + cyclicPath);
}

const bundle = createBundle(assets, entryAsset.id);

const bundlePath = path.resolve(".", "./bundle.js");
await Bun.write(bundlePath, bundle);

console.log(chalk.green(`Bundle created at ${bundlePath}`));
