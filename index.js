import path from "path";
import { hasCycle, generateDependencyGraph } from "./graph.mjs";
import { parseArgs } from "util";
// log setup
import chalk from "chalk";
const log = console.log;
const showError = (errMsg) => {
  log(chalk.red(errMsg));
  process.exit(1);
};

// parse arguments
const { values } = parseArgs({
  options: {
    entryPoint: {
      type: "string",
      short: "e",
    },
    root: {
      type: "string",
      short: "r",
    },
  },
  strict: true,
});

if (!Object.hasOwn(values, "entryPoint")) {
  showError("Entry point is required");
}

if (!Object.hasOwn(values, "root")) {
  showError("Root path is required");
}

const root = path.resolve(values.root);
const enterPath = path.resolve(root, values.entryPoint);

function createBundle(assets, entryPath) {
  let modules = "{";

  assets.forEach((asset) => {
    const scopeIsolation = `function(require,module,exports){${asset.content}}`;
    modules += `"${asset.assetPath}": [${scopeIsolation}, ${JSON.stringify(
      Object.fromEntries(asset.depMap)
    )}],`;
  });

  modules += "}";

  let bundle = `(function (modules, startPath) {
    function require(path) {
  
      const [fn, depMap] = modules[path];
      const module = { exports: {}};
      function localRequire(slug) {
        if (slug == startPath) {
          return {};
        }
        return require(depMap[slug]);
      }
      fn(localRequire, module, module.exports);
      return module.exports;
    }
    require(startPath);
  })(${modules}, "${entryPath}");`;

  return bundle;
}

const [assets, graph] = await generateDependencyGraph(enterPath, root);

if (hasCycle(graph, enterPath)) {
  showError("Cycle detected in the dependency graph");
}

const bundle =
  "// This code is generated by a toy bun-dler\n" +
  createBundle(assets, enterPath);

const bundlePath = path.resolve(".", "./bundle.js");
await Bun.write(bundlePath, bundle);

console.log(chalk.green(`Bundle created at ${bundlePath}`));
